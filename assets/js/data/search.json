[ { "title": "Basic Number Theory", "url": "/posts/getting-started/", "categories": "Level1, Week2", "tags": "Leve1, Week 2, mathe", "date": "2023-01-11 22:35:00 +0200", "snippet": "Modular ArithmeticDivision For every integer dividend n and divisor m ‚â† 0, there exists unique quotient q and remainder r such that.\\[n = qm + r\\]\\[0 ‚â§ r &lt; m\\] If r is the remainder after divi...", "content": "Modular ArithmeticDivision For every integer dividend n and divisor m ‚â† 0, there exists unique quotient q and remainder r such that.\\[n = qm + r\\]\\[0 ‚â§ r &lt; m\\] If r is the remainder after dividing n by m, we write n mod m = r An example showing.\\[if \\quad n = 14 \\quad \\textrm{and} \\quad m = 6\\]\\[q = 14 \\:/ \\:6 = 2 \\quad and \\quad \\:r \\:= \\:14 \\:\\% \\:6 \\:= \\:2\\] Note. C++ % operator is the same as mod only for positive dividends For negative dividends, % operator returns negative remainder (try it) \\[n = qm + r\\]\\[‚àím &lt; r ‚â§ 0\\] Reason: silly design, integer division, and requirement that\\[a\\: / \\:b \\:* \\:b \\:+ \\:a \\:\\% \\:b \\:== \\:a\\] To fix this, we need to add m at the end To avoid needing to deal with positive and negative dividends differently, just always add m and take mod m afterwards int mod(int a, int m) { return (a % m + m) % m;} An example showing.-3 % 10 = -3(-3 + 10 ) % 10 = 7Modular Additionint mod_add(int a, int b, int m) { return mod(mod(a, m) + mod(b, m), m); // assuming a + b does not overflow // return (a + b) % m;}Modular Subtractionint mod_sub(int a, int b, int m) { return mod(mod(a, m) - mod(b, m), m); // assuming assuming a - b does not overflow // return mod(a ‚Äì b, m);}Modular Multiplicationint mod_mul(int a, int b, int m) { return mod(mod(a, m) * mod(b, m), m); // assuming a * b does not overflow // return (a * b) % m;}Divisibility, PrimesDivisibility Integer $d$ divides integer $n$ if there is a $k$ such that $dk = n$ $d$ is a divisor or factor of $n$ $n$ is a multiple of $d$ $n$ is divisible by $d$ We write this as d | n Theorem: d | n if and only if n ‚â° 0 (mod d) Easy code:if(n % d == 0) { // n is divisible by d k = n / d;} Note. By our definition 0 is divisible by any integer No integer is divisible by 0, except‚Ä¶ 0 is divisible by 0 However, in practice, using the % operator with 0 right operand causes programs to crash (division by zero error)Primes An integer n &gt; 1 is prime if the only integers dividing it are 1 and n Otherwise it is composite Integers ‚â§ 1 are considered neither prime nor compositePrimality Testing Easy way: look for a divisor between 2 and n ‚àí 1 This is $O(n)$ time Theorem: If $n$ is composite, then it has a divisor ‚â§ $\\sqrt{n}$ Proof: If $ab = n$ and $ a &gt; \\sqrt{n}$ then $ \\frac{1}{a} &lt; \\frac{1}{\\sqrt{n}}$ Means, we only need to test $O(\\sqrt{n})$ integers for divisibilityPrimality Testing by Trial Division in $O(\\sqrt{n})$ bool is_prime(long long n) { bool ans = true; for(long long i = 2; i * i &lt;= n; i++) if(n % i == 0) ans = false; return ans;}Multiple Query Primality Testing Answer $q$ queries of the form: is $n$ prime? Constraints $q ‚â§ 10^7 $ $n ‚â§ 10^6 $ Answer each query by trial division ‚áí $O(q\\sqrt{n})$ which is too slow Goal: precompute answers so that we can answer each query in $O(1)$Sieve of Eratosthenes Idea: for any integer $i ‚â• 2$, ki is composite for all $k &gt; 1$ Initially assume all integers are prime Go through all integers and and mark all of their multiples (not equalto themselves) composite Theorem: The numbers that are not marked are prime Proof: If $p$ is not marked, then there is no $k &gt; 1$ and i between 2 andp where $ki = p$Sieve of Eratosthenes c++ codebool is_prime[MAX_N+1];void sieve(int n) { is_prime[0] = is_prime[1] = false; for(int i = 2; i &lt;= n; i++) is_prime[i] = true; for(int i = 2; i &lt;= n; i++) for(int k = 2; k * i &lt;= n; k++) is_prime[k * i] = false;}Sieve of Eratosthenes: Analysis Double nested for loop appears to be $O(n^2);$ however‚Ä¶ Only $ \\frac{n}{i} + C$ multiples for iteration $i$ \\[\\sum_{i=2}^{n} \\frac{n}{i} = n \\sum_{i=2}^n \\frac{i}{i}\\] The sum $\\sum_{i=2}^n \\frac{i}{i}$ is called the harmonic series Bounds for the harmonic series \\(\\sum_{i=2}^n \\frac{i}{i} = \\frac{1}{2} + \\frac{1}{3} +\\frac{1}{4} +\\frac{1}{5} +\\frac{1}{6} +\\frac{1}{7} +\\frac{1}{8} +\\frac{1}{9} +\\frac{1}{10} +\\frac{1}{11} +\\frac{1}{12} +\\frac{1}{13} +\\frac{1}{14} +\\frac{1}{15}\\)\\(\\: \\: \\: \\: \\: \\: \\: \\: \\: \\: \\: \\: \\: \\: \\: &lt; \\frac{1}{2} +\\frac{1}{2} +\\frac{1}{4} +\\frac{1}{4} +\\frac{1}{4} +\\frac{1}{4} +\\frac{1}{8} +\\frac{1}{8} +\\frac{1}{8} +\\frac{1}{8}+\\frac{1}{8}+\\frac{1}{8}+\\frac{1}{8}+\\frac{1}{8}\\)\\[= \\log_2 n\\](the number of powers of two up to n)A Minor Speedup Notice that when we reach some composite number i, all its multiples are already crossed out For all integers ki, if p divides i, then p also divides ki Only mark multiples of prime numbersbool is_prime[MAX_N+1];void sieve(int n) { is_prime[0] = is_prime[1] = false; for(int i = 2; i &lt;= n; i++) is_prime[i] = true; for(int i = 2; i &lt;= n; i++) if(is_prime[i]) for(int k = 2; k * i &lt;= n; k++) is_prime[k * i] = false;}Practice Problems problem 1Prime Factor Prime factor is the factor of the given number which is a prime number. Factors are the numbers you multiply together to get another number. In simple words, prime factor is finding which prime numbers multiply together to make the original number. Example: The prime factors of 15 are 3 and 5 (because 3√ó5=15, and 3 and 5 are prime numbers). Some interesting fact about Prime Factor : There is only one (unique!) set of prime factors for any number. In order to maintain this property of unique prime factorizations, it is necessary that the number one, 1, be categorized as neither prime nor composite. Prime factorizations can help us with divisibility, simplifying fractions, and finding common denominators for fractions. Pollard‚Äôs Rho is a prime factorization algorithm, particularly fast for a large composite number with small prime factors. Cryptography is the study of secret codes. Prime Factorization is very important to people who try to make (or break) secret codes based on numbers.How to print a prime factor of a number?solution:Given a number n, write a function to print all prime factors of n. For example, if the input number is 12, then output should be ‚Äú2 2 3‚Äù and if the input number is 315, then output should be ‚Äú3 3 5 7‚Äù.Following are the steps to find all prime factors: While n is divisible by 2, print 2 and divide n by 2. After step 1, n must be odd. Now start a loop from i = 3 to square root of n. While i divides n, print i and divide n by i, increment i by 2 and continue. If n is a prime number and is greater than 2, then n will not become 1 by above two steps. So print n if it is greater than 2.// Program to print all prime factors# include &lt;stdio.h&gt;# include &lt;math.h&gt;\t// A function to print all prime factors of a given number nvoid primeFactors(int n){\t// Print the number of 2s that divide n\twhile (n%2 == 0)\t{\t\tprintf(\"%d \", 2);\t\tn = n/2;\t}\t\t// n must be odd at this point. So we can skip\t// one element (Note i = i +2)\tfor (int i = 3; i &lt;= sqrt(n); i = i+2)\t{\t\t// While i divides n, print i and divide n\t\twhile (n%i == 0)\t\t{\t\t\tprintf(\"%d \", i);\t\t\tn = n/i;\t\t}\t}\t\t// This condition is to handle the case when n\t// is a prime number greater than 2\tif (n &gt; 2)\t\tprintf (\"%d \", n);}\t/* Driver program to test above function */int main(){\tint n = 315;\tprimeFactors(n);\treturn 0;}Euclidean algorithm for computing the greatest common divisorGiven two non-negative integers $a$ and $b$, we have to find their GCD (greatest common divisor), i.e. the largest number which is a divisor of both $a$ and $b$.It‚Äôs commonly denoted by $\\gcd(a, b)$. Mathematically it is defined as:\\[\\gcd(a, b) = \\max \\{k &gt; 0 : (k \\mid a) \\text{ and } (k \\mid b) \\}\\](here the symbol ‚Äú$\\mid$‚Äù denotes divisibility, i.e. ‚Äú$k \\mid a$‚Äù means ‚Äú$k$ divides $a$‚Äù)When one of the numbers is zero, while the other is non-zero, their greatest common divisor, by definition, is the second number. When both numbers are zero, their greatest common divisor is undefined (it can be any arbitrarily large number), but it is convenient to define it as zero as well to preserve the associativity of $\\gcd$. Which gives us a simple rule: if one of the numbers is zero, the greatest common divisor is the other number.The Euclidean algorithm, discussed below, allows to find the greatest common divisor of two numbers $a$ and $b$ in $O(\\log \\min(a, b))$.The algorithm was first described in Euclid‚Äôs ‚ÄúElements‚Äù (circa 300 BC), but it is possible that the algorithm has even earlier origins.AlgorithmOriginally, the Euclidean algorithm was formulated as follows: subtract the smaller number from the larger one until one of the numbers is zero. Indeed, if $g$ divides $a$ and $b$, it also divides $a-b$. On the other hand, if $g$ divides $a-b$ and $b$, then it also divides $a = b + (a-b)$, which means that the sets of the common divisors of ${a, b}$ and ${b,a-b}$ coincide.Note that $a$ remains the larger number until $b$ is subtracted from it at least $\\left\\lfloor\\frac{a}{b}\\right\\rfloor$ times. Therefore, to speed things up, $a-b$ is substituted with $a-\\left\\lfloor\\frac{a}{b}\\right\\rfloor b = a \\bmod b$. Then the algorithm is formulated in an extremely simple way:\\[\\gcd(a, b) = \\begin{cases}a,&amp;\\text{if }b = 0 \\\\ \\gcd(b, a \\bmod b),&amp;\\text{otherwise.}\\end{cases}\\]Implementationint gcd (int a, int b) { if (b == 0) return a; else return gcd (b, a % b);}Using the ternary operator in C++, we can write it as a one-liner.int gcd (int a, int b) { return b ? gcd (b, a % b) : a;}And finally, here is a non-recursive implementation:int gcd (int a, int b) { while (b) { a %= b; swap(a, b); } return a;}Note that since C++17, gcd is implemented as a standard function in C++.Time ComplexityThe running time of the algorithm is estimated by Lam√©‚Äôs theorem, which establishes a surprising connection between the Euclidean algorithm and the Fibonacci sequence:If $a &gt; b \\geq 1$ and $b &lt; F_n$ for some $n$, the Euclidean algorithm performs at most $n-2$ recursive calls.Moreover, it is possible to show that the upper bound of this theorem is optimal. When $a = F_n$ and $b = F_{n-1}$, $gcd(a, b)$ will perform exactly $n-2$ recursive calls. In other words, consecutive Fibonacci numbers are the worst case input for Euclid‚Äôs algorithm.Given that Fibonacci numbers grow exponentially, we get that the Euclidean algorithm works in $O(\\log \\min(a, b))$.Another way to estimate the complexity is to notice that $a \\bmod b$ for the case $a \\geq b$ is at least $2$ times smaller than $a$, so the larger number is reduced at least in half on each iteration of the algorithm.Least common multipleCalculating the least common multiple (commonly denoted LCM) can be reduced to calculating the GCD with the following simple formula:\\[\\text{lcm}(a, b) = \\frac{a \\cdot b}{\\gcd(a, b)}\\]Thus, LCM can be calculated using the Euclidean algorithm with the same time complexity:A possible implementation, that cleverly avoids integer overflows by first dividing $a$ with the GCD, is given here:int lcm (int a, int b) { return a / gcd(a, b) * b;}" }, { "title": "Level 0 - Week 2", "url": "/posts/level0-week2/", "categories": "Level0, week2", "tags": "Level0", "date": "2022-12-09 17:37:00 +0200", "snippet": "üìÑ | Weekly sheet Sheet linküóÉÔ∏è | Materials", "content": "üìÑ | Weekly sheet Sheet linküóÉÔ∏è | Materials" }, { "title": "Level 0 - Week 1", "url": "/posts/level0-week1/", "categories": "Level0, week1", "tags": "Level0", "date": "2022-12-09 17:36:00 +0200", "snippet": "üìÑ | Weekly sheet Sheet linküóÉÔ∏è | MaterialsData types are an important part of competitive programming as they help to store and manipulate data. The primary data types in C++ are int, char, float, ...", "content": "üìÑ | Weekly sheet Sheet linküóÉÔ∏è | MaterialsData types are an important part of competitive programming as they help to store and manipulate data. The primary data types in C++ are int, char, float, and double. Each of these data types has their own specific range and format specifier. If statements are used to execute a set of instructions only when a certain condition is true. They are used to check if certain conditions are met in order to determine if a certain set of instructions should be executed or not, and in this video we‚Äôll have an intensive explanation for each of these topics.‚ú® | Tips and Tricks session ‚úèÔ∏è | Sheet up solve A: Say Hello With C++ B: Basic Data Types C: Simple Calculator D: Difference E: Area of a Circle F: Get the LAST DIGIT G: Digits Summation H: Summation from 1 to N I: Two numbers J: Welcome for you with Conditions K: Multiples L: Max and Min M: The Brothers N: Capital or Small or Digit O: Char P: Calculator Q: First digit ! R: Coordinates of a Point S: Age in Days T: Interval U: Sort Numbers V: Float or int W: Comparison X: Mathematical Expression Y: Two intervals Z : The last 2 digits " }, { "title": "Level 0 - Getting Started", "url": "/posts/level0-getting-started/", "categories": "Level0, getting started", "tags": "Level0", "date": "2022-12-09 12:36:00 +0200", "snippet": "ü§î | How to start?The Purpose of this video is to show you the curriculum of this level in our comperhensive course, and give you a heads up to what you might expect. through this course we will ta...", "content": "ü§î | How to start?The Purpose of this video is to show you the curriculum of this level in our comperhensive course, and give you a heads up to what you might expect. through this course we will take you take you step-by-step through engaging video tutorials give you comperhensive problems that will gradually rise from beginner to expert you will be instructed by mentors that will be help you in every step along the way By the end of this course, you will be fluently solving problems using c++ and readyto enter the next level of competitive programming. ü§® | What is codeforces and how to use it?Codeforces is a website that hosts competitive programming contests. It is a great place to practice your skills and learn from others. In this video, we will show you how to use the website and how to submit your solutions.ŸÑŸà ÿπÿßŸàÿ≤ ÿ™ÿπÿ±ŸÅ ÿßŸÉÿ™ÿ± ÿπŸÜ ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ©" } ]
