[ { "title": "Basic Number Theory", "url": "/posts/getting-started/", "categories": "Level1, Week2", "tags": "Leve1, Week 2, mathe", "date": "2023-01-11 22:35:00 +0200", "snippet": "Modular ArithmeticDivision For every integer dividend n and divisor m ≠ 0, there exists unique quotient q and remainder r such that.\\[n = qm + r\\]\\[0 ≤ r &lt; m\\] If r is the remainder after divi...", "content": "Modular ArithmeticDivision For every integer dividend n and divisor m ≠ 0, there exists unique quotient q and remainder r such that.\\[n = qm + r\\]\\[0 ≤ r &lt; m\\] If r is the remainder after dividing n by m, we write n mod m = r An example showing.\\[if \\quad n = 14 \\quad \\textrm{and} \\quad m = 6\\]\\[q = 14 \\:/ \\:6 = 2 \\quad and \\quad \\:r \\:= \\:14 \\:\\% \\:6 \\:= \\:2\\] Note. C++ % operator is the same as mod only for positive dividends For negative dividends, % operator returns negative remainder (try it) \\[n = qm + r\\]\\[−m &lt; r ≤ 0\\] Reason: silly design, integer division, and requirement that\\[a\\: / \\:b \\:* \\:b \\:+ \\:a \\:\\% \\:b \\:== \\:a\\] To fix this, we need to add m at the end To avoid needing to deal with positive and negative dividends differently, just always add m and take mod m afterwards int mod(int a, int m) { return (a % m + m) % m;} An example showing.-3 % 10 = -3(-3 + 10 ) % 10 = 7Modular Additionint mod_add(int a, int b, int m) { return mod(mod(a, m) + mod(b, m), m); // assuming a + b does not overflow // return (a + b) % m;}Modular Subtractionint mod_sub(int a, int b, int m) { return mod(mod(a, m) - mod(b, m), m); // assuming assuming a - b does not overflow // return mod(a – b, m);}Modular Multiplicationint mod_mul(int a, int b, int m) { return mod(mod(a, m) * mod(b, m), m); // assuming a * b does not overflow // return (a * b) % m;}Divisibility, PrimesDivisibility Integer $d$ divides integer $n$ if there is a $k$ such that $dk = n$ $d$ is a divisor or factor of $n$ $n$ is a multiple of $d$ $n$ is divisible by $d$ We write this as d | n Theorem: d | n if and only if n ≡ 0 (mod d) Easy code:if(n % d == 0) { // n is divisible by d k = n / d;} Note. By our definition 0 is divisible by any integer No integer is divisible by 0, except… 0 is divisible by 0 However, in practice, using the % operator with 0 right operand causes programs to crash (division by zero error)Primes An integer n &gt; 1 is prime if the only integers dividing it are 1 and n Otherwise it is composite Integers ≤ 1 are considered neither prime nor compositePrimality Testing Easy way: look for a divisor between 2 and n − 1 This is $O(n)$ time Theorem: If $n$ is composite, then it has a divisor ≤ $\\sqrt{n}$ Proof: If $ab = n$ and $ a &gt; \\sqrt{n}$ then $ \\frac{1}{a} &lt; \\frac{1}{\\sqrt{n}}$ Means, we only need to test $O(\\sqrt{n})$ integers for divisibilityPrimality Testing by Trial Division in $O(\\sqrt{n})$ bool is_prime(long long n) { bool ans = true; for(long long i = 2; i * i &lt;= n; i++) if(n % i == 0) ans = false; return ans;}Multiple Query Primality Testing Answer $q$ queries of the form: is $n$ prime? Constraints $q ≤ 10^7 $ $n ≤ 10^6 $ Answer each query by trial division ⇒ $O(q\\sqrt{n})$ which is too slow Goal: precompute answers so that we can answer each query in $O(1)$Sieve of Eratosthenes Idea: for any integer $i ≥ 2$, ki is composite for all $k &gt; 1$ Initially assume all integers are prime Go through all integers and and mark all of their multiples (not equalto themselves) composite Theorem: The numbers that are not marked are prime Proof: If $p$ is not marked, then there is no $k &gt; 1$ and i between 2 andp where $ki = p$Sieve of Eratosthenes c++ codebool is_prime[MAX_N+1];void sieve(int n) { is_prime[0] = is_prime[1] = false; for(int i = 2; i &lt;= n; i++) is_prime[i] = true; for(int i = 2; i &lt;= n; i++) for(int k = 2; k * i &lt;= n; k++) is_prime[k * i] = false;}Sieve of Eratosthenes: Analysis Double nested for loop appears to be $O(n^2);$ however… Only $ \\frac{n}{i} + C$ multiples for iteration $i$ \\[\\sum_{i=2}^{n} \\frac{n}{i} = n \\sum_{i=2}^n \\frac{i}{i}\\] The sum $\\sum_{i=2}^n \\frac{i}{i}$ is called the harmonic series Bounds for the harmonic series \\(\\sum_{i=2}^n \\frac{i}{i} = \\frac{1}{2} + \\frac{1}{3} +\\frac{1}{4} +\\frac{1}{5} +\\frac{1}{6} +\\frac{1}{7} +\\frac{1}{8} +\\frac{1}{9} +\\frac{1}{10} +\\frac{1}{11} +\\frac{1}{12} +\\frac{1}{13} +\\frac{1}{14} +\\frac{1}{15}\\)\\(\\: \\: \\: \\: \\: \\: \\: \\: \\: \\: \\: \\: \\: \\: \\: &lt; \\frac{1}{2} +\\frac{1}{2} +\\frac{1}{4} +\\frac{1}{4} +\\frac{1}{4} +\\frac{1}{4} +\\frac{1}{8} +\\frac{1}{8} +\\frac{1}{8} +\\frac{1}{8}+\\frac{1}{8}+\\frac{1}{8}+\\frac{1}{8}+\\frac{1}{8}\\)\\[= \\log_2 n\\](the number of powers of two up to n)A Minor Speedup Notice that when we reach some composite number i, all its multiples are already crossed out For all integers ki, if p divides i, then p also divides ki Only mark multiples of prime numbersbool is_prime[MAX_N+1];void sieve(int n) { is_prime[0] = is_prime[1] = false; for(int i = 2; i &lt;= n; i++) is_prime[i] = true; for(int i = 2; i &lt;= n; i++) if(is_prime[i]) for(int k = 2; k * i &lt;= n; k++) is_prime[k * i] = false;}" } ]
